# Encryption with AWS KMS

Encryption is an integral part of the AWS KMS operations and its interactions with other AWS services. In this section we are going to get a better understanding of it and make some hands-on practices. AWS KMS mostly uses envelope encryption, but can also encrypt data directly without envelope encrytion.

Envelope encryption is the main encryption vehicle for AWS services using AWS KMS. 

The section is divided in the following parts:

* [How Envelope Encryption works in practice](https://github.com/charliejllewellyn/aws-kms-workshop/blob/master/Section-2-Encryption-with-AWS-KMS.md#how-envelope-encryption-works-in-practice)
* [Envelope encryption. Server Side Encryption](https://github.com/charliejllewellyn/aws-kms-workshop/blob/master/Section-2-Encryption-with-AWS-KMS.md#envelope-encryption-server-side-encryption)
* [Envelope encryption. Client Side Encryption](https://github.com/charliejllewellyn/aws-kms-workshop/blob/master/Section-2-Encryption-with-AWS-KMS.md#envelope-encryption-client-side-encryption)
* [Direct Encryption with AWS KMS](https://github.com/charliejllewellyn/aws-kms-workshop/blob/master/Section-2-Encryption-with-AWS-KMS.md#encryption-using-aws-kms-with-no-data-key)

---

## How Envelope Encryption works in practice

AWS KMS is able to encrypt and decrypt up to 4 kilobytes (4096 bytes) of data. With other volumes of data, normally you will use a data key to perform encryption operations outside KMS through envelope encryption.
Envelope encryption refers to the practice of protecting the data by encrypting it with a data key, and encrypting the data key itself with another encryption key, a CMK under KMS in this case.
See the following figure from [AWS KMS documentation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#enveloping).

![alt text](/res/S2F1.png)

<**Figure-1**>


AWS KMS is also capable of generating **data keys** to encrypt data from CMKs. 
**NOTE:** Data keys are only generated by AWS KMS, not stored or used to encrypt by AWS KMS itself. 

Data keys are very different from a CMK, which never leaves AWS KMS and is only used in memory. Besides, data keys can be obtained in plain text or encrypted. 

Once the data is encrypted and stored with a data key, the data key is stored encrypted with the data itself, while the plaintext version of the data key is deleted (for security best practices).

Therefore, to decrypt the data, the CMK needs to decrypt the encrypted data key and then, with the data key in plain text,   the decrypt operation can take place.
This adds a tier of protection to your data and better manageability. If a data key is compromised, only the service or data  using that particular data key is compromised, no other data. If only one key was used for all data encryption across the platform and it gets compromised, the whole platform data would be also compromised.

Let's see envelope encryption in action with AWS KMS.



### Step 1 - Create the secret text 

First thing we will do is to create a file with the data we want to encrypt under envelop encryption. A sample "secret" text file in this case with the text "Sample Secret Text to Encrypt".
```
$ sudo echo "Sample Secret Text to Encrypt" > samplesecret.txt
```


### Step 2- Generate the data key

Next, we ask AWS KMS to generate a data key referencing a CMK. The CMK is referenced to encrypt the data key.  We will use the CMK created with our key material, this is the material we imported, key alias is "**FirstCMK**". Use the following command to generate a symmetric data key with 256 bits length encrypted with our CMK.
```
$ aws kms generate-data-key --key-id alias/FirstCMK --key-spec AES_256 --encryption-context project=workshop
```
You will notice that the command will fail to run. Our current Role with Power User permissions does not have enough privileges to generate a data key. As per least privilege best practices, we are providing permissions as needed in policies attached to the role that can be easily tracked and detached when such permission for that user is not needed any more.

We need to provide with permission to generate a data key. 

You need to go back to the AWS console, in the services area navigate to IAM and go to "**Roles**" and select the role **KMSWorkshop-InstanceInitRole**. We are going to update policy we created earlier "**KMSWorkshop-AdditionalPermissions**".

In the "Write" section, select "**GenerateDataKey**" operation. Additionally select "**Encrypt**", "**Decrypt**" and the tagging operations **as you can see in image below**, we will need them for the nexts steps. and "**Any**" as resource. 

![alt text](/res/S2F16.png)

<**Figure-1**>

Once completed save the changes.

Once the policy is updated, if you try the same command again, it will succeed now. The command will return a JSON output  with:
* the plaintext data key - Plaintext key in b64 encoding
* the KeyId used to encrypt plaintext data key
* A CiphertextBlob which is the encrypted data key generated, in base64 enconding. 

Write these values down, we are going to needed them shortly.

```
$ aws kms generate-data-key --key-id alias/FirstCMK --key-spec AES_256 --encryption-context project=workshop

{
    "Plaintext": "97**********FEFE*ROL****************OOL", 
    "KeyId": "arn:aws:kms:eu-west-1:-your-account.id:key/-KeyId-used-to-encrypt", 
    "CiphertextBlob": "*********************+**********M05/D********************************************D12bL*****2A**"
}
```

Please note the command used a new parameter: "**encryption-context**". This is an optional key-pair  value that provides additional context about the data and that needs to be provided as well when decrypting the data. This is because, when provided, it is bound to the cryptographic operation.

Encryption Context, besides helping with the integrity of the encrypted data, it has many other uses. For example: use it to set policies, to provide Grants or to monitor encrypt/decrypt operations in CloudTrail (will see later in this section).
See **additional information about encryption context** in [this part of the AWS KMS  documentation](https://docs.aws.amazon.com/kms/latest/developerguide/encryption-context.html).



### Step 3 - Encrypt the secret text

We have now a data key 256 bit length that we can use to encrypt. We can use any encryption tool or library with the data key we have created to encrypt our data. ** Remember that AWS KMS does not store or use the data key for encryption **. 

Let's use OpenSSL library to encrypt the sample file we want to be secret with our newly created data key.

We need to decode the plaintext data key we obtained above (Plaintext), as it is in b64, and store it in a file.

Use a command like the one below, where the argument for "echo" command is the plaintext key obtained when creating data key. The output file name will be **datakeyPlainText.txt**.

```
$ echo '97**********FEFE*ROL****************OOL' | base64 --decode > datakeyPlainText.txt
```


We wil do the same for the encrypted plaintext (the CipherTextBlob) we have obtained when creating data key. Therefore, the argument for "echo" command is the CipherTextBlob value of the data key genetarion's JSON output. We wil save it and save it in a file name **datakeyEncrypted.txt**:

```
$ echo '*********************+**********M05/D********************************************D12bL*****2A**' | base64 --decode > datakeyEncrypted.txt
```
Now we are ready to encrypt the file with the text we want to keep secret. Remember we stored the text in the file **samplesecret.txt**. For the job, we will use the OpenSSL library again, encrypting with AES256:

```
$ openssl enc -e -aes256 -in samplesecret.txt -out encryptedSecret.txt -k fileb://datakeyPlainText.txt  
```

This command encrypts in AES256 bits the input file "**samplesecret.txt**", with the data key in Plaintext stored in file "**datakeyPlainText.txt**" and saves the encrypted output to file "**encryptedSecret.txt**".
We have our text now encrypted in the file **encryptedSecret.txt**. You can do a "more" or "cat" operation over it. You will notice the encryption. The original text is not recognizable.

```
$ more encryptedSecret.txt 

FF******f??FZ?***3
```


Following envelope encryption best practices, you will now store the file encrypted with the encrypted data key and delete the plaintext key, avoiding getting it compromised. 

```
$ rm datakeyPlainText.txt
```



### Step 4 - Decrypt the encrypted secret text

If we want now to reverse the operation and decrypt the secret text stored in **encryptedSecret.txt**, it will be a 2 steps procedure. 
Remember that we don´t have the data key in plaintext to be used for decryption, we have removed it for security best practices. 

We have the data key **encrypted** that was provided to us when calling the AWS KMS generate data key operation and that we stored as b64 decoded in file  **datakeyEncrypted.txt**.

Therefore, the first step is to decrypt the data key with the appropriate Master Key (CMK) that was used to encrypt it. In this case we will use the command aws decrypt (see full reference [in this part of documentation](https://docs.aws.amazon.com/cli/latest/reference/kms/decrypt.html)). This command will tell AWS KMS to revert the encryption made over the data key. 

**Note:** We don´t need to provide the KeyId that was used to encrypt the data key, the encrypted data contains metadata to provide this information to AWS KMS.

```
$ aws kms decrypt --ciphertext-blob fileb://datakeyEncrypted.txt

An error occurred (InvalidCiphertextException) when calling the Decrypt operation: 

```

The command will fail because when we generated the data key in plaintext and encrypted it with our CMK in the **step 2**, we used an **encryption context**. 
This encryption context was used in the encryption operation of the plaintext data key, this is: to produce the encrypted data key (the CiphertextBlob). Therefore we need to provide the encryption context to be able to decrypt correctly:

```
$ aws kms  decrypt --encryption-context project=workshop --ciphertext-blob fileb://datakeyEncrypted.txt
{
    "Plaintext": "97**********FEFE*ROL****************OOL", 
    "KeyId": "arn:aws:kms:eu-west-1:your-account-id:key/your-imported-key-id"
}
```

Great! As you can see, the output of the command has the data key in Plaintext. We had removed it and only stored it encrypted, but with AWS KMS and the appropriate CMK, we have it back. 

We need now  to decode it from base64 and use it to decrypt the encrypted secret file, **encryptedSecret.txt**. Again using  the OpenSSL library:  Copy the plaintext key and use it as an input to "**echo**", as you can see below.

```
$ echo '97**********FEFE*ROL****************OOL' | base64 --decode > datakeyPlainText.txt
```
Now that we have the data key in Plaintext and decoded from base64, let's decrypt:

```

$  openssl enc -d -aes256 -in encryptedSecret.txt -k fileb://datakeyPlainText.txt
Sample Secret Text to Encrypt
```

Good job, we have the secret text "Sample Secret Text to Encrypt" decrypted.
The data to be encrypted and decrypted by your applications would use envelope encryption in a similar way. It is a powerful mechanism, enabled by AWS KMS CMKs, to protect in two tiers, the integrity and confidentiality of your data.

By completing this part of the workshop you now have a better understanding of what envelope ecnryption is, let's now see how it applies for AWS services working with AWS KMS.

----

# S3 Serverside Encryption
In this seciton we will:
- tighten our administrative key policy
- use a second IAM user with full S3 permission via IAM to upload data
- Enforce default bucket encryption
- demonstrate what access the second user now has
- Add KMS policy access to allow the user to encrypt and encrypt data in S3

### Step 1
- Login as your AWS administrator
- Open the IAM console, select **roles** and search for *team*
- Open the role and copy the **arn**
- Open the KMS console and select the key you created earlier
- Edit the key policy and edit the key policy
- Change the principal to the **arn** you got from the previous step
This will now only allow this role to manage this key

### Step 2
- Open the AWS console and open CloudFormation
- Click the stack you created earlier and click on the outputs tab
- Open a new browser and login with details provided
- Open the S3 console and upload a file. It should succeed

### Step 3
- As the account administrator open S3 and set the default encryption to your FirstCMK key
- Go back to your other browser session and now try uploading content. It should fail....why?

### Step 4
- As the account administrator open the KMS console
- Add the following section to the key policiy
```
        {
            "Sid": "User key permissions",
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::XXXXXXXXXXXX:user/kmsTest"
            },
            "Action": [
                "kms:Decrypt",
                "kms:Encrypt",
                "kms:GenerateDataKey",
                "kms:GenerateDataKeyWithoutPlaintext"
            ],
            "Resource": "*"
        }
```
**NOTE: change the account Id**

### Step 5
- Go back to your other browser session and now try uploading content. This time it should pass.

You have completed the second section of the workshop. In the next section we will work with a real-life Web App and will try to implement best practices. You can now [navigate to the next section of the Workshop](https://github.com/charliejllewellyn/aws-kms-workshop/blob/master/Section-3-Working-with-Web-App.md)




